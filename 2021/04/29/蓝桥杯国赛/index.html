<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>蓝桥杯国赛 | Vanilla's Blog</title><meta name="keywords" content="蓝桥"><meta name="author" content="vanilla"><meta name="copyright" content="vanilla"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TIP:数组范围设置时比题目要求大一点，防止溢出！！！质数拆分2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？注意：分解方案不考虑顺序，如 2 + 2017 &#x3D; 2019 和 2017 + 2 &#x3D; 2019 属于同一种方案。 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;mat">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝桥杯国赛">
<meta property="og:url" content="http://example.com/2021/04/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B/index.html">
<meta property="og:site_name" content="Vanilla&#39;s Blog">
<meta property="og:description" content="TIP:数组范围设置时比题目要求大一点，防止溢出！！！质数拆分2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？注意：分解方案不考虑顺序，如 2 + 2017 &#x3D; 2019 和 2017 + 2 &#x3D; 2019 属于同一种方案。 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;mat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-04-29T12:24:54.000Z">
<meta property="article:modified_time" content="2021-06-04T11:22:34.000Z">
<meta property="article:author" content="vanilla">
<meta property="article:tag" content="蓝桥">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/04/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '蓝桥杯国赛',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-04 19:22:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Vanilla's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Vanilla's Blog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">蓝桥杯国赛</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-29T12:24:54.000Z" title="发表于 2021-04-29 20:24:54">2021-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-04T11:22:34.000Z" title="更新于 2021-06-04 19:22:34">2021-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="蓝桥杯国赛"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="TIP-数组范围设置时比题目要求大一点，防止溢出！！！"><a href="#TIP-数组范围设置时比题目要求大一点，防止溢出！！！" class="headerlink" title="TIP:数组范围设置时比题目要求大一点，防止溢出！！！"></a>TIP:数组范围设置时比题目要求大一点，防止溢出！！！</h2><h2 id="质数拆分"><a href="#质数拆分" class="headerlink" title="质数拆分"></a>质数拆分</h2><p>2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？<br>注意：分解方案不考虑顺序，如 2 + 2017 &#x3D; 2019 和 2017 + 2 &#x3D; 2019 属于同一种方案。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;math.h&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt;v;
long long dp[2020] = &#123; 0 &#125;;
bool is(int x) &#123;
    if (x == 2)return true;
    int k = sqrt(x);
    int flag = 1;
    for (int i = 2;i &lt;= k;i++) &#123;
        if (x%i == 0) &#123;
            flag = 0;break;
        &#125;
    &#125;
    if (flag)return true;
    else return false;
&#125;
int main() &#123;
    for (int i = 2;i &lt;= 2019;i++) &#123;
        if (is(i)) &#123;
            v.push_back(i);
        &#125;
    &#125;
    v.push_back(2020);
    int len = v.size();
    dp[0] = 1;
    for (int i = 0;i &lt; len;i++) &#123;
        for (int j = 2019;j &gt;= v[i];j--) &#123;
            dp[j] += dp[j - v[i]];
        &#125;
    &#125;
    cout &lt;&lt; dp[2019];
&#125;
</code></pre>
<p>dp[i]表示v[i]有多少种拆分方法</p>
<h3 id="答案：55965365465060"><a href="#答案：55965365465060" class="headerlink" title="答案：55965365465060"></a>答案：55965365465060</h3><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><pre><code>dp[n]表示n有多少种拆分方法，其中dp[0]算一种
dp[j] += dp[j - v[i]]表示将j拆分成v[i]和j-v[i],而j-v[i]本身有dp[j-v[i]]种拆分方法。j又可以拆分成许许多多个v[i]和j-v[i](在v[i]&lt;j的前提下)
j从2019往前计算，防止重复算入
</code></pre>
<h2 id="阶乘约数"><a href="#阶乘约数" class="headerlink" title="阶乘约数"></a>阶乘约数</h2><p>定义阶乘 n! &#x3D; 1 × 2 × 3 × · · · × n。<br>请问 100! （100 的阶乘）有多少个正约数。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;math.h&gt;
using namespace std;
long long ans = 1;
int arr[100] = &#123; 0 &#125;;
bool iszhi(int n) &#123;
    if (n == 1 || n == 2)return true;
    int k = sqrt(n);
    int flag = 1;
    for (int i = 2;i &lt;= k;i++) &#123;
        if (n%k == 0) &#123;
            flag = 0;
            break;
        &#125;
    &#125;
    if (flag)return true;
    else return false;
&#125;
int main() &#123;
    for (int i = 2;i &lt;= 100;i++) &#123;
        int n = i;
        while (n!=1) &#123;
            for (int j = 2;j &lt;= n;j++) &#123;
                if (iszhi(j) &amp;&amp; n%j==0) &#123;
                    arr[j]++;
                    n /= j;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    for (int i = 2;i &lt;= 100;i++) &#123;
        if (arr[i]) &#123;
            ans *= (arr[i] + 1);
        &#125;
    &#125;
    cout &lt;&lt; ans;
&#125;
</code></pre>
<h3 id="算术基本定理："><a href="#算术基本定理：" class="headerlink" title="算术基本定理："></a>算术基本定理：</h3><p><img src="https://note.youdao.com/yws/api/personal/file/1F4BB92BF8D24B149DD37EC1990396DD?method=download&shareKey=2bd3731cfc577ee63be19267ecee7630" alt="avatar"></p>
<h3 id="答案：39001250856960000"><a href="#答案：39001250856960000" class="headerlink" title="答案：39001250856960000"></a>答案：39001250856960000</h3><h2 id="本质上升序列"><a href="#本质上升序列" class="headerlink" title="本质上升序列"></a>本质上升序列</h2><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
long long ans = 0;
int dp[200];
int main() &#123;
    string s;
    getline(cin, s);
    int len = s.length();
    for (int i = 0;i &lt; 200;i++) &#123;
        dp[i] = 1;
    &#125;
    for (int i = 0;i &lt; len;i++) &#123;
        for (int j = len - 1;j &gt; i;j--) &#123;
            if (s[j] &gt; s[i]) &#123;
                dp[j] += dp[i];
            &#125;
            if (s[j] == s[i]) &#123;
                dp[j] -= dp[i];
            &#125;
        &#125;
    &#125;
    for (int i = 0;i &lt; len;i++) &#123;
        ans += dp[i];
    &#125;
    cout &lt;&lt; ans;
&#125;
</code></pre>
<h3 id="分析：动态规划"><a href="#分析：动态规划" class="headerlink" title="分析：动态规划"></a>分析：动态规划</h3><pre><code>dp[i]表示：前i个字符串中有多少组递增序列
自身算一组，所以dp数组初始化为1
如果s[j]&lt;s[i]，s[j]+=s[i]
如果相同，s[j]-=s[i]
</code></pre>
<h3 id="答案：3616159"><a href="#答案：3616159" class="headerlink" title="答案：3616159"></a>答案：3616159</h3><h2 id="玩具蛇"><a href="#玩具蛇" class="headerlink" title="玩具蛇"></a>玩具蛇</h2><p>小蓝有一条玩具蛇，一共有 16 节，上面标着数字 1 至 16。每一节都是一<br>个正方形的形状。相邻的两节可以成直线或者成 90 度角。<br>小蓝还有一个 4 × 4 的方格盒子，用于存放玩具蛇，盒子的方格上依次标着<br>字母 A 到 P 共 16 个字母。<br>小蓝可以折叠自己的玩具蛇放到盒子里面。他发现，有很多种方案可以将<br>玩具蛇放进去。<br>下图给出了两种方案：<br><img src="https://note.youdao.com/yws/api/personal/file/C20880732147452BA580A31B94F86FF3?method=download&shareKey=c18a237fdd99f61c8a851bee0adc43db" alt="avatar"><br>请帮小蓝计算一下，总共有多少种不同的方案。如果两个方案中，存在玩<br>具蛇的某一节放在了盒子的不同格子里，则认为是不同的方案。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int flag[4][4] = &#123; 0 &#125;;
int shu[4] = &#123; 1,0,-1,0 &#125;;
int heng[4] = &#123; 0,1,0,-1 &#125;;//方向
bool is(int i,int j) &#123;
    if (i &gt;= 0 &amp;&amp; i &lt; 4 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; 4)return true;
    else return false;
&#125;
long long ans = 0;
void dfs(int a, int b, int x) &#123;
    if (x == 16) &#123;
        ans++;
        return;
    &#125;
    for (int i = 0;i &lt; 4;i++) &#123;
        if (is(a + heng[i], b + shu[i]) &amp;&amp; flag[a + heng[i]][b + shu[i]]==0) &#123;
            flag[a + heng[i]][b + shu[i]] = 1;
            dfs(a + heng[i], b + shu[i], x + 1);
            flag[a + heng[i]][b + shu[i]] = 0;
        &#125;
    &#125;
&#125;
int main() &#123;
    for (int i = 0;i &lt; 4;i++) &#123;
        for (int j = 0;j &lt; 4;j++) &#123;
            flag[i][j] = 1;
            dfs(i, j, 1);
            memset(flag, 0, 16 * 4);
        &#125;
    &#125;
    cout &lt;&lt; ans;
&#125;
</code></pre>
<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><h3 id="答案：552"><a href="#答案：552" class="headerlink" title="答案：552"></a>答案：552</h3><h2 id="皮亚诺曲线距离"><a href="#皮亚诺曲线距离" class="headerlink" title="皮亚诺曲线距离"></a>皮亚诺曲线距离</h2><p>皮亚诺曲线是一条平面内的曲线。<br>下图给出了皮亚诺曲线的 1 阶情形，它是从左下角出发，经过一个 3 × 3 的方格中的每一个格子，最终到达右上角的一条曲线<br><img src="https://note.youdao.com/yws/api/personal/file/3D32B709BBEC41489DAC15AF17D558DD?method=download&shareKey=70ef2ffbfae9be1e0c87217d04b13a38" alt="avatar"><br>下图给出了皮亚诺曲线的 2 阶情形，它是经过一个 3^2^ × 3^2^ 的方格中的每一个格子的一条曲线。它是将 1 阶曲线的每个方格由 1 阶曲线替换而成。<br><img src="https://note.youdao.com/yws/api/personal/file/5BCBB7F8BF454417B5B5300BD2EEFC67?method=download&shareKey=1ffffed6dc7bb2fb67556a0434ae27d4" alt="avatar"><br>下图给出了皮亚诺曲线的 3 阶情形，它是经过一个 33 × 33 的方格中的每一个格子的一条曲线。它是将 2 阶曲线的每个方格由 1 阶曲线替换而成。<br><img src="https://note.youdao.com/yws/api/personal/file/653FF3B93E594BE2A2C4267B3890BA95?method=download&shareKey=2c78114fb118ea5500f0a26998a844df" alt="avatar"><br>皮亚诺曲线总是从左下角开始出发，最终到达右上角。<br>我们将这些格子放到坐标系中，对于 k 阶皮亚诺曲线，左下角的坐标是(0, 0)，右上角坐标是 (3k − 1, 3k − 1)，右下角坐标是 (3k − 1, 0)，左上角坐标是(0, 3k − 1)。<br>给定 k 阶皮亚诺曲线上的两个点的坐标，请问这两个点之间，如果沿着皮亚诺曲线走，距离是到少？<br>【输入格式】<br>输入的第一行包含一个正整数 k，皮亚诺曲线的阶数。第二行包含两个整数 x1, y1，表示第一个点的坐标。<br>第十一届蓝桥杯大赛软件类决赛 C&#x2F;C++ 大学 B 组第三行包含两个整数 x2, y2，表示第二个点的坐标。<br>【输出格式】<br>输出一个整数，表示给定的两个点之间的距离。<br>【样例输入】<br>1<br>0 0<br>2 2<br>【样例输出】<br>8<br>【样例输入】<br>2<br>0 2<br>0 3<br>【样例输出】<br>13<br>【评测用例规模与约定】<br>对于 30% 的评测用例，0 ≤ k ≤ 10。<br>对于 50% 的评测用例，0 ≤ k ≤ 20。<br>对于所有评测用例，0 ≤ k ≤ 100, 0 ≤ x1, y1, x2, y2 &lt; 3k, x1, y1, x2, y2 ≤ 1018。<br>数据保证答案不超过 1018。</p>
<p>代码：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;math.h&gt;
using namespace std;
long long id(long long x, long long y) &#123;
    if (x == 0) &#123;
        if (y == 0)return 1;
        if (y == 1)return 2;
        if (y == 2)return 3;
    &#125;
    else if (x == 1) &#123;
        if (y == 0)return 6;
        if (y == 1)return 5;
        if (y == 2)return 4;
    &#125;
    else if (x == 2) &#123;
        if (y == 0)return 7;
        if (y == 1)return 8;
        if (y == 2)return 9;
    &#125;
&#125;
long long fun(long long n, long long x, long long y) &#123;
    long long k = id(x / (long long)pow(3, n - 1), y / (long long)pow(3, n - 1));
    if (n == 1)return k - 1;
    long long xx, yy;
    xx = x % (long long)pow(3, n - 1);
    yy = y % (long long)pow(3, n - 1);
    switch (k) &#123;
    case 2:case 8:xx = (long long)pow(3, n - 1) - 1 - xx;break;
    case 4:case 6:yy = (long long)pow(3, n - 1) - 1 - yy;break;
    case 5:xx = (long long)pow(3, n - 1) - 1 - xx;yy = (long long)pow(3, n - 1) - 1 - yy;break;
    &#125;
    return (k - 1)*(long long)pow(3, n - 1)*(long long)pow(3, n - 1) + fun(n - 1, xx, yy);
&#125;
int main() &#123;
    long long n, x1, y1, x2, y2;
    cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;
    long long ans;
    ans = fabs(fun(n, x2, y2) - fun(n, x1, y1));
    cout &lt;&lt; ans;
&#125;
</code></pre>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>递归。<br>fun(n,x,y)表示，在n阶曲线中，从(0,0)到(x,y)要走的步数。<br><img src="https://note.youdao.com/yws/api/personal/file/FDE4A27CEC2D47AA994C9DF99307FC7B?method=download&shareKey=d469b0adc4c9fd66a643c431b950bf7c" alt="avatar"><br>每一次递归，将图形分为9各部分，k表示(x,y)在第k部分，从(0,0)到(x,y)要走的步数为：(k-1)x每个部分的格子数+fun(n-1,xx,yy)。<br>xx和yy为(x,y)在第k部分中的新坐标，注意翻转。</p>
<h2 id="游园安排"><a href="#游园安排" class="headerlink" title="游园安排"></a>游园安排</h2><p>L 星球游乐园非常有趣，吸引着各个星球的游客前来游玩。小蓝是 L 星球游乐园的管理员。<br>为了更好的管理游乐园，游乐园要求所有的游客提前预约，小蓝能看到系统上所有预约游客的名字。每个游客的名字由一个大写英文字母开始，后面跟0 个或多个小写英文字母。游客可能重名。<br>小蓝特别喜欢递增的事物。今天，他决定在所有预约的游客中，选择一部分游客在上午游玩，其他的游客都在下午游玩，在上午游玩的游客要求按照预约的顺序排列后，名字是单调递增的，即排在前面的名字严格小于排在后面的名字。<br>一个名字 A 小于另一个名字 B 是指：存在一个整数 i，使得 A 的前 i 个字母与 B 的前 i 个字母相同，且 A 的第 i+ 1 个字母小于 B 的第 i+ 1 个字母。（如果 A 不存在第 i + 1 个字母且 B 存在第 i + 1 个字母，也视为 A 的第 i + 1 个字母小于 B 的第 i + 1 个字母）<br>作为小蓝的助手，你要按照小蓝的想法安排游客，同时你又希望上午有尽量多的游客游玩，请告诉小蓝让哪些游客上午游玩。如果方案有多种，请输出上午游玩的第一个游客名字最小的方案。如果此时还有多种方案，请输出第一个游客名字最小的前提下第二个游客名字最小的方案。如果仍然有多种，依此类推选择第三个、第四个……游客名字最小的方案。<br>【输入格式】<br>输入包含一个字符串，按预约的顺序给出所有游客的名字，相邻的游客名字之间没有字符分隔。<br>【输出格式】<br>按预约顺序输出上午游玩的游客名单，中间不加任何分隔字符。<br>【样例输入】<br>WoAiLanQiaoBei<br>【样例输出】<br>AiLanQiao<br>【评测用例规模与约定】<br>对于 20% 的评测数据，输入的总长度不超过 20 个字母。<br>对于 50% 的评测数据，输入的总长度不超过 300 个字母。<br>对于 70% 的评测数据，输入的总长度不超过 10000 个字母。<br>对于所有评测数据，每个名字的长度不超过 10 个字母，输入的总长度不超过 1000000 个字母。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
string id[1000000];
int n = 0;
int maxi;
int ans[1000000] = &#123; 0 &#125;;
int xulie[1000000];
bool daxie(char c) &#123;
    if (c &gt;= &#39;A&#39;&amp;&amp;c &lt;= &#39;Z&#39;)return true;
    else return false;
&#125;
bool is(string a, string b) &#123;
    a[0] += 32;
    b[0] += 32;
    for (int i = 0;i &lt; a.length();i++) &#123;
        if (a[i] &gt; b[i])return true;
        else if (a[i] == b[i])continue;
        else if (a[i] &lt; b[i])return false;
    &#125;
&#125;
void dfs(int cur)
&#123;
    if (ans[maxi]--) &#123;
        dfs(xulie[cur]);
        cout &lt;&lt; id[cur];
    &#125;
&#125;
int main() &#123;
    string str;
    getline(cin, str);
    for (int i = 0;i &lt; str.length();i++) &#123;
        if (daxie(str[i])) &#123;
            id[n] += str[i];
            for (int j = 1;i+j &lt; str.length();j++) &#123;
                if (daxie(str[i+j])) &#123;
                    i = i+j - 1;
                    break;
                &#125;
                id[n] += str[i+j];
            &#125;
            n++;
        &#125;
    &#125;
    for (int i = 0;i &lt; n;i++) &#123;
        ans[i] = 1;
        for (int j = 0;j &lt;i;j++) &#123;
            if (is(id[i], id[j])) &#123;
                if (ans[j] + 1 &gt; ans[i]) &#123;
                    xulie[i] = j;
                    ans[i] = ans[j] + 1;
                &#125;
            &#125;
        &#125;
    &#125;
    int max = ans[0];
    for (int i = 1;i &lt; n;i++) &#123;
        if (ans[i] &gt; max) &#123;
            max = ans[i];
            maxi = i;
        &#125;
    &#125;
    dfs(maxi);
&#125;
</code></pre>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>ans[i]表示以id[i]结尾的最长序列有多少个人<br>ans[j]+1表示加上id[j]这个人<br>xulie[i]&#x3D;j，id[j]为以id[j]结尾的最长序列的倒数第二个人名<br>通过dfs从最大序列最后一个id不断向前搜索</p>
<h2 id="激光样式"><a href="#激光样式" class="headerlink" title="激光样式"></a>激光样式</h2><p>x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？<br>显然，如果只有3台机器，一共可以成5种样式，即：<br>全都关上（sorry, 此时无声胜有声，这也算一种）开一台，共3种<br>开两台，只1种<br>30台就不好算了，国王只好请你帮忙了。<br>要求提交一个整数，表示30台激光器能形成的样式种数。<br>注意，只提交一个整数，不要填写任何多余的内容。</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;math.h&gt;
using namespace std;
long long ans = 0;
void dfs(int last,int n) &#123;
    if (n == 30) &#123;
        ans++;
        return;
    &#125;
    if (last == 1) &#123;
        dfs(0, n+1);
    &#125;
    else &#123;
        dfs(0, n + 1);
        dfs(1, n + 1);
    &#125;
&#125;
int main() &#123;
    dfs(0, 1);
    dfs(1, 1);
    cout &lt;&lt; ans;
&#125;
</code></pre>
<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>dfs<br>1表示开灯，0表示不开<br>last表示左灯的状态，如果是1开灯，则边上的不能开，只能代0<br>如果0，则可开可不开</p>
<h3 id="答案：2178309"><a href="#答案：2178309" class="headerlink" title="答案：2178309"></a>答案：2178309</h3><h2 id="最优包含"><a href="#最优包含" class="headerlink" title="最优包含"></a>最优包含</h2><p>我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。<br>给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？<br>输入格式<br>输入两行，每行一个字符串。</p>
<p>第一行的字符串为 S，第二行的字符串为 T。</p>
<p>两个字符串均非空而且只包含大写英文字母。</p>
<p>输出格式<br>输出一个整数，表示答案。</p>
<p>数据范围<br>1≤|T|≤|S|≤1000<br>输入样例：<br>ABCDEABCD<br>XAABZ<br>输出样例：<br>3</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int dp[1005][1005];
int min(int a, int b) &#123;
    if (a &lt; b)return a;
    else return b;
&#125;
int main() &#123;
    string s1, s2;
    getline(cin, s1);
    getline(cin, s2);
    for(int i=0;i&lt;1001;i++)
        for (int j = 0;j &lt; 1001;j++) &#123;
            dp[i][j] = 9999;
        &#125;//初始化
    for (int i = 0;i &lt; s1.length();i++) &#123;
        if (s1[i] == s2[0])dp[i][0] = 0;//相同无需改变，为0
        else if(i&gt;0)dp[i][0] = min(1,dp[i-1][0]);
        else dp[i][0]=1;//不同需要改变，为1
    &#125;//初始化
    for (int i = 1;i &lt; s1.length();i++) &#123;
        for (int j = 1;j &lt; s2.length();j++) &#123;
            if (s1[i] == s2[j]) &#123;
                dp[i][j] = dp[i - 1][j - 1];
            &#125;
            else &#123;
                dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j]);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dp[s1.length()-1][ s2.length()-1];
&#125;
</code></pre>
<h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><pre><code>动态规划
dp[i][j]表示要使S的前i+1个字母包含T的前j+1个字母，需要修改多少个字母
每次循环选择最小
相同：不用改变，和前S前i个字母包含T的j个字母需要改变的字母一样，即dp[i-1][j-1]
不通：1、和S前i个字母包含T的j个字母需要改变的字母增加1，因为要改变S[i],即dp[i-1][j-1]+1
     2、不管S[i]，从前i-1的序列中改变字母，使S的前i-1个字母包含T的前j个字母，即dp[i-1][j]
     
</code></pre>
<h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。<br>对于一个 1∼n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t+1 单调序列。<br>例如，排列 (1,4,2,3) 是一个 3 单调序列，其中 4 和 2 都是折点。<br>给定 n 和 k，请问 1∼n 的所有排列中有多少个 k 单调队列？<br>输入格式<br>输入一行包含两个整数 n,k。</p>
<p>输出格式<br>输出一个整数，表示答案。</p>
<p>答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。</p>
<p>数据范围<br>1≤k≤n≤500<br>输入样例：<br>4 2<br>输出样例：<br>12</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;iostream&gt;
using namespace std;
int dp[501][501];
int main() &#123;
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    dp[1][1] = 1;
    dp[2][1] = 2;
    for (int i = 3;i &lt;= n;i++) &#123;
        for (int j = 1;j &lt;= k;j++) &#123;
            dp[i][j] = dp[i - 1][j] * j + dp[i - 1][j - 1] * 2 + dp[i - 1][j - 2] * (i - j);
            dp[i][j] %= 123456;
        &#125;
    &#125;
    cout &lt;&lt; dp[n][k];
&#125;
</code></pre>
<h3 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h3><pre><code>dp[i][j]表示1~i中j单调队列的方案数
动态分析，考虑从i-1到i会增加多少方案

经过分类讨论，一共有三种情况：增加0个、1个、2个折点
</code></pre>
<h3 id="i加在山谷边上"><a href="#i加在山谷边上" class="headerlink" title="i加在山谷边上"></a>i加在山谷边上</h3><p>1、<img src="https://note.youdao.com/yws/api/personal/file/A3408A34CBA94ED59E6E8CF6B26A7C76?method=download&shareKey=7f9990eaaf3e4292bfc586843be7ee93" alt="avatar"><br>1变3，增加了2个<br>2、<img src="https://note.youdao.com/yws/api/personal/file/2EA20FCCDC4D4984BE357CD0DCAB7026?method=download&shareKey=d75df77f0b2a4b2e1e7c203233339b8b" alt="avatar"><br>2变2，增加了0个</p>
<h3 id="i加在山峰边上"><a href="#i加在山峰边上" class="headerlink" title="i加在山峰边上"></a>i加在山峰边上</h3><p>1、<img src="https://note.youdao.com/yws/api/personal/file/2EA20FCCDC4D4984BE357CD0DCAB7026?method=download&shareKey=d75df77f0b2a4b2e1e7c203233339b8b" alt="avatar"><br>2变2，增加了0个<br>2、<img src="https://note.youdao.com/yws/api/personal/file/5332F1E9FDB642D19E8F0940BFD7E9BB?method=download&shareKey=850bcea8172f0e0af2287fde5aa645d2" alt="avatar"><br>1变1，增加了0个</p>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>1、<img src="https://note.youdao.com/yws/api/personal/file/5CA7E440E305420BB1BB50B49C66AD91?method=download&shareKey=2e5e985007a21bc51adbf94b0a9275e8" alt="avatar"><br>0变2，增加了2个<br>2、<img src="https://note.youdao.com/yws/api/personal/file/FF14747606EA46C6868376549CD3763B?method=download&shareKey=6842f5fb948160fa1159e087298bd18c" alt="avatar"><br>0变1，增加了1个</p>
<pre><code>所以：dp[i][j]=dp[i-1][j]*x(增加0个折点)+dp[i-1][j-1]*y(增加1个折点)+dp[i-1][j-2]*z(增加2个折点)
需要找x，y，z的表达式、
</code></pre>
<h3 id="增加0个折点有几种方案-x-："><a href="#增加0个折点有几种方案-x-：" class="headerlink" title="增加0个折点有几种方案(x)："></a>增加0个折点有几种方案(x)：</h3><p>1、将i加在山峰两边各为一种方案，即山峰数<em>2<br>2、最左的两个数递减时，加在最左，或最右的两个数递增时，加在最右<br>x&#x3D;山峰数</em>2+[最左两数递减为真]+[最右两数递增为真]<br>当山峰数&#x3D;山谷数时，最左两数和最右两数要么都递增，要么都递减,只会满足其一为真。此时x&#x3D;(j-1)&#x2F;2<em>2+1<br>当山峰数&#x3D;山谷数+1时，最左递增，最右递减，两个都为假。此时x&#x3D;j&#x2F;2</em>2&#x3D;j<br>当山峰数&#x3D;山谷数-1时，最左递减，最右递增，两个都为真。此时x&#x3D;(j&#x2F;2-1)*2+2&#x3D;j<br>综上，x&#x3D;j</p>
<h3 id="增加1个折点有几种方案-y-："><a href="#增加1个折点有几种方案-y-：" class="headerlink" title="增加1个折点有几种方案(y)："></a>增加1个折点有几种方案(y)：</h3><p>1、放在最左两个数之间<br>2、放在最右两个数之间<br>y&#x3D;2</p>
<h3 id="增加2个折点有几种方案-z-："><a href="#增加2个折点有几种方案-z-：" class="headerlink" title="增加2个折点有几种方案(z)："></a>增加2个折点有几种方案(z)：</h3><pre><code>在i-1个数中，一共有i种放i的方法
在dp[i-1][j-2]中，有j-2中方法使折点加0，有2种方法使折点加1
所以z=i-(j-2)-2=i-j
</code></pre>
<h3 id="dp-i-j-x3D-dp-i-1-j-j-dp-i-1-j-1-2-dp-i-1-j-2-i-j"><a href="#dp-i-j-x3D-dp-i-1-j-j-dp-i-1-j-1-2-dp-i-1-j-2-i-j" class="headerlink" title="dp[i][j] &#x3D; dp[i - 1][j] * j + dp[i - 1][j - 1] * 2 + dp[i - 1][j - 2] * (i - j);"></a>dp[i][j] &#x3D; dp[i - 1][j] * j + dp[i - 1][j - 1] * 2 + dp[i - 1][j - 2] * (i - j);</h3><h2 id="磁砖样式"><a href="#磁砖样式" class="headerlink" title="磁砖样式"></a>磁砖样式</h2><p>小明家的一面装饰墙原来是 3<em>10 的小方格。<br>现在手头有一批刚好能盖住2个小方格的长方形瓷砖。<br>瓷砖只有两种颜色：黄色和橙色。<br>小明想知道，对于这么简陋的原料，可以贴出多少种不同的花样来。<br>小明有个小小的强迫症：忍受不了任何2</em>2的小格子是同一种颜色。<br>（瓷砖不能切割，不能重叠，也不能只铺一部分。另外，只考虑组合图案，请忽略瓷砖的拼缝）<br>显然，对于 2<em>3 个小格子来说，口算都可以知道：一共10种贴法，如【p1.png所示】<br>但对于 3</em>10 的格子呢？肯定是个不小的数目，请你利用计算机的威力算出该数字。</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include &lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
long long ans = 0;
int gezi[3][10];
map&lt;int, int&gt;m;
bool check() &#123;
    for (int i = 0;i &lt; 2;i++) &#123;
        for (int j = 0;j &lt; 9;j++) &#123;
            if (gezi[i][j] == gezi[i + 1][j + 1] &amp;&amp; gezi[i][j] == gezi[i + 1][j] &amp;&amp; gezi[i][j] == gezi[i][j + 1]) &#123;
                return false;
            &#125;
        &#125;
    &#125;
    int t = 1;
    long long num = 0;
    for (int i = 0;i &lt; 3;i++) &#123;
        for (int j = 0;j &lt; 10;j++) &#123;
            num += t * gezi[i][j];
            t *= 2;
        &#125;
    &#125;
    if (!m[num]) &#123;
        m[num] = 1;
        return true;
    &#125;
    else return false;
&#125;
void fill(int i, int j) &#123;
    if (i &gt; 2) &#123;
        if (check()) &#123;
            ans++;
        &#125;
        return;
    &#125;
    if (gezi[i][j] == -1) &#123;
        if (j &lt; 9 &amp;&amp; gezi[i][j + 1] == -1) &#123;//横着
            for (int n = 0;n &lt; 2;n++) &#123;
                gezi[i][j] = n;
                gezi[i][j + 1] = n;
                if (j + 1 &lt; 9) &#123;
                    fill(i, j + 2);
                &#125;
                else &#123;
                    fill(i + 1, 0);
                &#125;
                gezi[i][j] = -1;
                gezi[i][j + 1] = -1;
            &#125;
        &#125;
        if (i &lt; 2 &amp;&amp; gezi[i + 1][j] == -1) &#123;//竖着
            for (int n = 0;n &lt; 2;n++) &#123;
                gezi[i][j] = n;
                gezi[i + 1][j] = n;
                if (j &lt; 9) &#123;
                    fill(i, j + 1);
                &#125;
                else &#123;
                    fill(i + 1, 0);
                &#125;
                gezi[i][j] = -1;
                gezi[i + 1][j] = -1;
            &#125;
        &#125;
    &#125;
    else if (j &lt; 9) &#123;
        fill(i, j + 1);
    &#125;
    else if (j &gt;= 9) &#123;
        fill(i + 1, 0);
    &#125;
&#125;
int main() &#123;
    memset(gezi, -1, sizeof(gezi));
    fill(0, 0);
    cout &lt;&lt; ans;
&#125;
</code></pre>
<h3 id="答案：101466"><a href="#答案：101466" class="headerlink" title="答案：101466"></a>答案：101466</h3><h3 id="分析：dfs-hash"><a href="#分析：dfs-hash" class="headerlink" title="分析：dfs+hash"></a>分析：dfs+hash</h3><pre><code>gezi[3][10]表示一个3行10列的墙，每个格子初始化为-1，表示未被填入颜色
按照从左往右，从上往下的顺序填格子
可以横竖，每次横竖可以选择两种颜色(用for循环两次实现，0和1各代表一种颜色)
如果j=9，则表示这一行填满了，要填下一行，转到fill(i+1,0)
如果j&lt;9，在横着填的情况下，直接跳过下一个，转到fill(i,j+2);在竖着填的情况下，转到下一个fill(i,j+1)
如果该格子不为-1，表示已经被填过了(由上一行竖着填的某个引起),则直接转到下一个，如果以满，转到下一行第一个
i一旦大于2，则表示全部填完，用check函数检验已经填满的是否符合
符合条件：1、相邻的四个不能相同；2、确保不是已有过的填法，用hash实现记录已有填法
在横竖的分支语句中，最后要回溯到-1，不然后续无法判断是否已经填色
</code></pre>
<h2 id="发现环"><a href="#发现环" class="headerlink" title="发现环"></a>发现环</h2><p>问题描述<br>　　小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。<br>　　不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。<br>　　为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？</p>
<p>输入格式<br>　　第一行包含一个整数N。<br>　　以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。</p>
<p>　　对于30%的数据，1 &lt;&#x3D; N &lt;&#x3D; 1000<br>　　对于100%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 100000， 1 &lt;&#x3D; a, b &lt;&#x3D; N</p>
<p>　　输入保证合法。</p>
<p>输出格式<br>　　按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。</p>
<p>样例输入<br>5<br>1 2<br>3 1<br>2 4<br>2 5<br>5 3<br>样例输出<br>1 2 3 5</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
vector&lt;int&gt;mp[100005];
queue&lt;int&gt;que;
int degree[100005] = &#123; 0 &#125;;
int flag[100005] = &#123; 0 &#125;;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    int len = n;
    while (n--) &#123;
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        degree[x]++;
        degree[y]++;
        mp[x].push_back(y);
        mp[y].push_back(x);
    &#125;
    for (int i = 1;i &lt;= len;i++) &#123;
        if (degree[i] == 1) &#123;
            que.push(i);
            flag[i] = 1;
        &#125;
    &#125;
    while (!que.empty()) &#123;
        int temp = que.front();
        que.pop();
        for (int i = 0;i &lt; mp[temp].size();i++) &#123;
            degree[mp[temp][i]]--;
            if (degree[mp[temp][i]] == 1) &#123;
                que.push(mp[temp][i]);
                flag[mp[temp][i]] = 1;
            &#125;
        &#125;
    &#125;
    for (int i = 1;i &lt;= len;i++) &#123;
        if (flag[i] == 0) &#123;
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="分析：拓扑排序"><a href="#分析：拓扑排序" class="headerlink" title="分析：拓扑排序"></a>分析：拓扑排序</h3><pre><code>初始化flag数组为0
将正常路线上的flag设为1，剩下的就是在回路上的电脑
从度初始就为1的节点开始寻找正常节点(只有一个前驱，一个后继)；将下一个度自减1，通过自减后的度是否为1判断是否在正常线路上
</code></pre>
<h2 id="对局匹配"><a href="#对局匹配" class="headerlink" title="对局匹配"></a>对局匹配</h2><p>问题描述<br>　　小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。<br>　　小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。<br>　　现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, … AN。<br>　　小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？<br>输入格式<br>　　第一行包含两个个整数N和K。<br>　　第二行包含N个整数A1, A2, … AN。<br>　　对于30%的数据，1 &lt;&#x3D; N &lt;&#x3D; 10<br>　　对于100%的数据，1 &lt;&#x3D; N &lt;&#x3D; 100000, 0 &lt;&#x3D; Ai &lt;&#x3D; 100000, 0 &lt;&#x3D; K &lt;&#x3D; 100000<br>输出格式<br>　　一个整数，代表答案。<br>样例输入<br>10 0<br>1 4 2 8 5 7 1 4 2 8<br>样例输出<br>6</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int num[100005] = &#123; 0 &#125;;
int m = 0;
int max(int a, int b, int c) &#123;
    if (a &gt; b&amp;&amp;a &gt; c)return a;
    else if (b &gt; c)return b;
    else return c;
&#125;
int main() &#123;
    int n, k;
    int ans = 0;
    cin &gt;&gt; n &gt;&gt; k;
    if (k != 0) &#123;
        for (int i = 0;i &lt; n;i++) &#123;
            int temp;
            cin &gt;&gt; temp;
            num[temp]++;
            if (temp &gt; m)m = temp;
        &#125;
        for (int j = 0;j &lt; k;j++) &#123;
            int count = 0;int dp[100005] = &#123; 0 &#125;;int team[100005] = &#123; 0 &#125;;
            for (int i = j;i &lt;= m;i += k) &#123;
                team[count++] += num[i];
            &#125;
            dp[0] = team[0];
            if (team[0] &gt; team[1])dp[1] = dp[0];
            else dp[1] = team[1];
            for (int i = 2;i &lt; count;i++) &#123;
                 dp[i] = max(dp[i - 1], dp[i - 2] + team[i], team[i]);
            &#125;
            ans += dp[count - 1];
            &#125;
        cout &lt;&lt; ans;
    &#125;
    else &#123;
        for (int i = 0;i &lt; n;i++) &#123;
            int temp;
            cin &gt;&gt; temp;
            num[temp]++;
        &#125;
        for (int i = 0;i &lt; 100000;i++) &#123;
            if (num[i])ans++;
        &#125;
        cout &lt;&lt; ans;
    &#125;
&#125;
</code></pre>
<h3 id="解析：动态规划"><a href="#解析：动态规划" class="headerlink" title="解析：动态规划"></a>解析：动态规划</h3><pre><code>num[n]表示积分为n的人数
分为k组，每组的成员分别是0+k的倍数、1+k的倍数、2+k的倍数......(k-1)+k的倍数
同时选择不同组的成员必然不会匹配，在同组中，差值不为k也不会匹配到，所以需要把各组能取的最大人数加起来
dp[i]表示在第j组，前i个数(从小到大排)中，可以取的最多人数，所以相邻的只可取其一
team[i]表示分数为i的人数
dp[i] = max(dp[i - 1], dp[i - 2] + team[i], team[i])
dp[i-1]表示不取分数为i的人数，dp[i-2]+team[i]表示取分数为i的人数，team[i]防止前面的人数都是0
</code></pre>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">vanilla</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B/">http://example.com/2021/04/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Vanilla's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%93%9D%E6%A1%A5/">蓝桥</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/21/python/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/14/%E5%89%8D%E7%BC%80%E5%92%8C/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前缀和</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/15/%E8%93%9D%E6%A1%A5-3-15-3-21/" title="蓝桥(3.15-3.21)"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-15</div><div class="title">蓝桥(3.15-3.21)</div></div></a></div><div><a href="/2021/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B8%80%E4%B8%AA%E6%9C%88%E5%86%B2%E5%88%BA/" title="蓝桥杯一个月冲刺"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">蓝桥杯一个月冲刺</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">vanilla</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TIP-%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E8%AE%BE%E7%BD%AE%E6%97%B6%E6%AF%94%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82%E5%A4%A7%E4%B8%80%E7%82%B9%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%BA%A2%E5%87%BA%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">1.</span> <span class="toc-text">TIP:数组范围设置时比题目要求大一点，防止溢出！！！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">质数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A55965365465060"><span class="toc-number">2.1.</span> <span class="toc-text">答案：55965365465060</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%E7%BA%A6%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">阶乘约数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">算术基本定理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A39001250856960000"><span class="toc-number">3.2.</span> <span class="toc-text">答案：39001250856960000</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">本质上升序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.1.</span> <span class="toc-text">分析：动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A3616159"><span class="toc-number">4.2.</span> <span class="toc-text">答案：3616159</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%A9%E5%85%B7%E8%9B%87"><span class="toc-number">5.</span> <span class="toc-text">玩具蛇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs"><span class="toc-number">5.1.</span> <span class="toc-text">dfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A552"><span class="toc-number">5.2.</span> <span class="toc-text">答案：552</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9A%AE%E4%BA%9A%E8%AF%BA%E6%9B%B2%E7%BA%BF%E8%B7%9D%E7%A6%BB"><span class="toc-number">6.</span> <span class="toc-text">皮亚诺曲线距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E5%9B%AD%E5%AE%89%E6%8E%92"><span class="toc-number">7.</span> <span class="toc-text">游园安排</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BF%80%E5%85%89%E6%A0%B7%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">激光样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="toc-number">8.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">8.2.</span> <span class="toc-text">分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A2178309"><span class="toc-number">8.3.</span> <span class="toc-text">答案：2178309</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%8C%85%E5%90%AB"><span class="toc-number">9.</span> <span class="toc-text">最优包含</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A-1"><span class="toc-number">9.1.</span> <span class="toc-text">解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">排列数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="toc-number">10.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A-2"><span class="toc-number">10.2.</span> <span class="toc-text">解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E5%8A%A0%E5%9C%A8%E5%B1%B1%E8%B0%B7%E8%BE%B9%E4%B8%8A"><span class="toc-number">10.3.</span> <span class="toc-text">i加在山谷边上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E5%8A%A0%E5%9C%A8%E5%B1%B1%E5%B3%B0%E8%BE%B9%E4%B8%8A"><span class="toc-number">10.4.</span> <span class="toc-text">i加在山峰边上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="toc-number">10.5.</span> <span class="toc-text">其他情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A00%E4%B8%AA%E6%8A%98%E7%82%B9%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88-x-%EF%BC%9A"><span class="toc-number">10.6.</span> <span class="toc-text">增加0个折点有几种方案(x)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A01%E4%B8%AA%E6%8A%98%E7%82%B9%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88-y-%EF%BC%9A"><span class="toc-number">10.7.</span> <span class="toc-text">增加1个折点有几种方案(y)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A02%E4%B8%AA%E6%8A%98%E7%82%B9%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88-z-%EF%BC%9A"><span class="toc-number">10.8.</span> <span class="toc-text">增加2个折点有几种方案(z)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp-i-j-x3D-dp-i-1-j-j-dp-i-1-j-1-2-dp-i-1-j-2-i-j"><span class="toc-number">10.9.</span> <span class="toc-text">dp[i][j] &#x3D; dp[i - 1][j] * j + dp[i - 1][j - 1] * 2 + dp[i - 1][j - 2] * (i - j);</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%A0%96%E6%A0%B7%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">磁砖样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-3"><span class="toc-number">11.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A101466"><span class="toc-number">11.2.</span> <span class="toc-text">答案：101466</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9Adfs-hash"><span class="toc-number">11.3.</span> <span class="toc-text">分析：dfs+hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E7%8E%AF"><span class="toc-number">12.</span> <span class="toc-text">发现环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-4"><span class="toc-number">12.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.</span> <span class="toc-text">分析：拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%B1%80%E5%8C%B9%E9%85%8D"><span class="toc-number">13.</span> <span class="toc-text">对局匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-5"><span class="toc-number">13.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">13.2.</span> <span class="toc-text">解析：动态规划</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A04-5/" title="机器学习4.5"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习4.5"/></a><div class="content"><a class="title" href="/2022/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A04-5/" title="机器学习4.5">机器学习4.5</a><time datetime="2022-04-05T05:16:04.000Z" title="发表于 2022-04-05 13:16:04">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/web%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B04-5/" title="web课堂笔记4.5"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="web课堂笔记4.5"/></a><div class="content"><a class="title" href="/2022/04/05/web%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B04-5/" title="web课堂笔记4.5">web课堂笔记4.5</a><time datetime="2022-04-05T00:15:22.000Z" title="发表于 2022-04-05 08:15:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803-29/" title="机器学习基础3.29"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习基础3.29"/></a><div class="content"><a class="title" href="/2022/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803-29/" title="机器学习基础3.29">机器学习基础3.29</a><time datetime="2022-03-29T05:11:23.000Z" title="发表于 2022-03-29 13:11:23">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/web%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B03-29/" title="web课堂笔记3.29"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="web课堂笔记3.29"/></a><div class="content"><a class="title" href="/2022/03/29/web%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B03-29/" title="web课堂笔记3.29">web课堂笔记3.29</a><time datetime="2022-03-29T00:17:06.000Z" title="发表于 2022-03-29 08:17:06">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/26/web%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B03-26/" title="web课堂笔记3.26"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="web课堂笔记3.26"/></a><div class="content"><a class="title" href="/2022/03/26/web%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B03-26/" title="web课堂笔记3.26">web课堂笔记3.26</a><time datetime="2022-03-26T02:11:11.000Z" title="发表于 2022-03-26 10:11:11">2022-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By vanilla</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>